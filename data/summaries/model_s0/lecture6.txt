This lecture focused on nested and subqueries in SQL, exploring their forms, uses, and the concept of monotonicity in query evaluation. Building on earlier knowledge of SQL projections, joins, and grouping, the lecture introduced subqueries—queries embedded within other queries. These can appear in the SELECT, FROM, or WHERE clauses and may return either scalar values or entire relations. Although possible to use, nested queries are often less efficient, and unnesting (rewriting them as joins or simpler queries) is preferred when feasible.

Subqueries in the SELECT clause were illustrated through examples that compute attributes such as movie genres, actor counts, and average salaries. Equivalent results can often be obtained using joins and aggregations, though certain conditions—such as outer joins—affect their equivalence. Subqueries in the FROM clause can serve as temporary tables, either through inline views or with common table expressions (CTEs). This structure helps organize complex filtering steps while maintaining readability. Subqueries in the WHERE clause typically evaluate logical conditions. The lecture emphasized existential quantifiers using EXISTS or IN, allowing tests for the presence or membership of related tuples, and demonstrated how these can be rewritten as joins.

Universal quantifiers (“for all”) present more difficulty, as SQL lacks direct constructs for them. Examples showed how to retrieve actors who only acted in action movies or movies where all actors earn above a threshold, using NOT IN or NOT EXISTS to mimic universal conditions. These required multi-step logic and showcased that such queries are fundamentally more complex. The lecture concluded with the concept of monotone and non-monotone queries: monotone queries never lose results when more data are added and can usually be unnested, while non-monotone queries—those involving negation, universal quantification, or aggregation—cannot. This distinction underpins whether optimization through subquery unnesting is possible.