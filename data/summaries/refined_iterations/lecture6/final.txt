This lecture examined **nested SQL queries (subqueries)**—their types, uses, and links to logical quantifiers and query monotonicity. Building on prior SQL topics (projections, selections, joins, grouping, and aggregates), it defined a *subquery* as a query embedded within another. Subqueries can appear in **SELECT**, **FROM**, or **WHERE** clauses and may return either a single value or a relation. The key guideline was to **avoid nested queries when possible**, because they are often less efficient and can usually be replaced through **subquery unnesting**, transforming them into equivalent join or grouping forms.

**Subqueries in the SELECT clause** demonstrated correlated subqueries that compute derived attributes—for example, retrieving a movie’s genre or the average actor salary. However, these expressions can often be unnested into joins. The slides compared such pairs of queries, highlighting that while they often yield identical results, differences may arise depending on conditions like outer joins or filters.

**Subqueries in the FROM clause** showed how subqueries or *common table expressions (CTEs)* can define intermediate relations to simplify multi-step filtering, as in computing ratings between two thresholds. This *subquery refactoring* aids readability but can still be flattened through **unnesting** into a single SELECT–FROM–WHERE statement.

**Subqueries in the WHERE clause** introduced logical **quantifiers**.  
– **Existential quantifiers** (*EXISTS*, *IN*) test whether some tuple satisfies a condition (e.g., an actor appearing in any Sci‑Fi movie). These correspond to “there exists” logic and can typically be converted into equivalent join queries.  
– **Universal quantifiers** (“for all”) are more complex because SQL lacks direct syntax. The slides illustrated deriving them indirectly—such as finding actors who acted **only** in Action movies or movies whose actors all earn over \$100K. These can be expressed using *NOT IN*, *NOT EXISTS*, or *> ALL* (though the latter is unsupported in SQLite). Such patterns show that universal quantifiers require multi-step reasoning and cannot always be easily unnested.

The lecture concluded with the concept of **query monotonicity**. A query is *monotone* if adding tuples to input tables never removes results. Standard `SELECT–FROM–WHERE` queries without aggregates, negation, or subqueries are monotone, meaning their **unnesting** preserves semantics. Queries involving universal quantifiers, negation, or aggregates are **non‑monotone**, so their nested structures cannot be safely unnested. Understanding which forms are monotone explains why some nested queries can be optimized while others must remain nested.
